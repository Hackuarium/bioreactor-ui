{"version":3,"file":"static/js/231.fe9b98ca.chunk.js","mappings":"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","sources":["../node_modules/delay/index.js","../node_modules/legoino-navigator-serial/src/Action.js","../node_modules/legoino-navigator-serial/src/Device.js","../node_modules/legoino-navigator-serial/src/DevicesManager.js","../node_modules/legoino-navigator-serial/src/util/checkSerial.js","../node_modules/legoino-navigator-serial/src/util/EventEmitter.js"],"sourcesContent":["'use strict';\n\n// From https://github.com/sindresorhus/random-int/blob/c37741b56f76b9160b0b63dae4e9c64875128146/index.js#L13-L15\nconst randomInteger = (minimum, maximum) => Math.floor((Math.random() * (maximum - minimum + 1)) + minimum);\n\nconst createAbortError = () => {\n\tconst error = new Error('Delay aborted');\n\terror.name = 'AbortError';\n\treturn error;\n};\n\nconst createDelay = ({clearTimeout: defaultClear, setTimeout: set, willResolve}) => (ms, {value, signal} = {}) => {\n\tif (signal && signal.aborted) {\n\t\treturn Promise.reject(createAbortError());\n\t}\n\n\tlet timeoutId;\n\tlet settle;\n\tlet rejectFn;\n\tconst clear = defaultClear || clearTimeout;\n\n\tconst signalListener = () => {\n\t\tclear(timeoutId);\n\t\trejectFn(createAbortError());\n\t};\n\n\tconst cleanup = () => {\n\t\tif (signal) {\n\t\t\tsignal.removeEventListener('abort', signalListener);\n\t\t}\n\t};\n\n\tconst delayPromise = new Promise((resolve, reject) => {\n\t\tsettle = () => {\n\t\t\tcleanup();\n\t\t\tif (willResolve) {\n\t\t\t\tresolve(value);\n\t\t\t} else {\n\t\t\t\treject(value);\n\t\t\t}\n\t\t};\n\n\t\trejectFn = reject;\n\t\ttimeoutId = (set || setTimeout)(settle, ms);\n\t});\n\n\tif (signal) {\n\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t}\n\n\tdelayPromise.clear = () => {\n\t\tclear(timeoutId);\n\t\ttimeoutId = null;\n\t\tsettle();\n\t};\n\n\treturn delayPromise;\n};\n\nconst delay = createDelay({willResolve: true});\ndelay.reject = createDelay({willResolve: false});\ndelay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);\ndelay.createWithTimers = ({clearTimeout, setTimeout}) => {\n\tconst delay = createDelay({clearTimeout, setTimeout, willResolve: true});\n\tdelay.reject = createDelay({clearTimeout, setTimeout, willResolve: false});\n\treturn delay;\n};\n\nmodule.exports = delay;\n// TODO: Remove this for the next major release\nmodule.exports.default = delay;\n","const STATUS_CREATED = 0;\nconst STATUS_COMMAND_SENT = 1;\nconst STATUS_ANSWER_PARTIALLY_RECEIVED = 2;\nconst STATUS_ANSWER_RECEIVED = 3;\nconst STATUS_RESOLVED = 4;\nconst STATUS_ERROR = 5;\n\nexport class Action {\n  constructor(command, options = {}) {\n    this.currentTimeout = undefined;\n    this.command = command;\n    this.timeout = options.timeout === undefined ? 1000 : options.timeout;\n    this.answer = '';\n    this.status = STATUS_CREATED;\n    this.creationTimestamp = Date.now();\n    this.promise = new Promise((resolve, reject) => {\n      this.reject = reject;\n      this.resolve = resolve;\n    });\n    this.finishedPromise = new Promise((resolve) => {\n      this.finished = resolve;\n    });\n  }\n\n  isFinished() {\n    return this.status === STATUS_RESOLVED || this.status === STATUS_ERROR;\n  }\n\n  setTimeout() {\n    if (this.currentTimeout) {\n      clearTimeout(this.currentTimeout);\n    }\n    this.currentTimeout = setTimeout(() => {\n      if (this.status === STATUS_RESOLVED || this.status === STATUS_ERROR) {\n        return;\n      }\n      this.status = STATUS_ERROR;\n      this.reject('Timeout');\n      this.finished();\n    }, this.timeout);\n  }\n\n  start() {\n    this.startTimestamp = Date.now();\n    this.status = STATUS_COMMAND_SENT;\n    this.setTimeout();\n  }\n\n  appendAnswer(buffer) {\n    let string = new TextDecoder().decode(buffer);\n    this.status = STATUS_ANSWER_PARTIALLY_RECEIVED;\n    this.answer += string;\n    if (!this.answer.replace(/\\r/g, '').endsWith('\\n\\n')) return;\n    let lines = this.answer.split(/\\r?\\n/);\n    if (lines.length > 0 && lines[lines.length - 1] === '') {\n      lines = lines.filter((line) => line);\n      this.status = STATUS_ANSWER_RECEIVED;\n      this.resolve(lines.join('\\n'));\n      this.finished();\n      this.status = STATUS_RESOLVED;\n    }\n  }\n}\n","/* eslint-disable no-await-in-loop */\n\nimport delay from 'delay';\n\nimport { Action } from './Action';\n\nconst debug = () => {};\n\nexport const STATUS_OPENING = 1;\nexport const STATUS_OPENED = 2;\nexport const STATUS_CLOSED = 3;\nexport const STATUS_MISSING = 9;\nexport const STATUS_ERROR = 10;\n\nexport class Device {\n  constructor(serialPort, options = {}) {\n    this.status = STATUS_OPENING;\n    this.id = undefined;\n    this.serialPort = serialPort;\n    this.baudRate = options.baudRate || 115200;\n    this.queue = [];\n    this.action = undefined;\n    this.interCommandDelay = options.interCommandDelay;\n    this.defaultCommandExpirationDelay = 2000;\n    this.encoder = new TextEncoder();\n    this.decoder = new TextDecoder();\n  }\n\n  isReady() {\n    return this.status === STATUS_OPENED;\n  }\n\n  /** restart process queue if the previous one was finished */\n  async ensureProcessQueue() {\n    debug('ensureProcessQueue');\n    if (!this.currentProcessQueue) {\n      this.currentProcessQueue = this.runProcessQueue();\n    }\n    return this.currentProcessQueue;\n  }\n\n  async runProcessQueue() {\n    while (this.queue.length > 0) {\n      this.action = this.queue.shift();\n\n      if (this.action) {\n        this.action.start();\n        await this.write(`${this.action.command}\\n`);\n        await this.read(this.action);\n        await this.action.finishedPromise;\n        this.action = undefined;\n        await delay(this.interCommandDelay);\n      }\n    }\n    this.currentProcessQueue = undefined;\n  }\n\n  async getStatus() {\n    return {\n      value: this.status,\n    };\n  }\n\n  async ensureOpen() {\n    debug(`Ensure open`);\n    if (this.status !== STATUS_OPENED) {\n      return this.open();\n    }\n  }\n\n  async open() {\n    debug(`Opening`);\n    await this.serialPort.open({\n      baudRate: this.baudRate,\n    });\n    this.reader = this.serialPort.readable.getReader();\n    this.writer = this.serialPort.writable.getWriter();\n    this.id = await this.get('uq');\n    this.status = STATUS_OPENED;\n  }\n\n  /*\n   We need to add this command in the queue and wait it resolves or rejects\n  */\n  async get(command, options = {}) {\n    const {\n      commandExpirationDelay = this.defaultCommandExpirationDelay,\n    } = options;\n\n    const action = new Action(command, {\n      timeout: commandExpirationDelay,\n    });\n\n    this.queue.push(action);\n    this.ensureProcessQueue();\n    return action.promise;\n  }\n\n  error(error) {\n    debug(`Error ${this.port.path}`);\n    debug(error);\n    this.status = STATUS_ERROR;\n    this.emit('adapter', {\n      event: 'Error',\n      value: error,\n    });\n  }\n\n  close() {\n    debug(`Close`);\n    this.status = STATUS_CLOSED;\n  }\n\n  async write(data) {\n    const dataArrayBuffer = this.encoder.encode(`${data}\\n`);\n    return this.writer.write(dataArrayBuffer);\n  }\n\n  async read(action) {\n    while (!action.isFinished()) {\n      action.appendAnswer((await this.reader.read()).value);\n      delay(10);\n    }\n  }\n}\n","/* eslint-disable no-await-in-loop */\nimport delay from 'delay';\n\nimport { Device, STATUS_MISSING, STATUS_OPENED, STATUS_CLOSED } from './Device';\nimport EventEmitter from './util/EventEmitter';\nimport checkSerial from './util/checkSerial';\n\nconst debug = () => {};\n\n/**\n * Class creating a new serial bridge to manage serial ports.\n * @param {object} [options={}]\n * @param {function} [options.portFilter=[{usbProductId:37384, usbVendorId:6991}]] Filter the serial ports to address.\n * @param {number} [options.baudRate=57200] Baud rate\n * @param {number} [options.interCommandDelay=100] Time to wait between commands in [ms]\n * @param {number} [options.defaultCommandExpirationDelay=100] Time to wait for answer before timeout\n */\nexport class DevicesManager extends EventEmitter {\n  constructor(serial, options = {}) {\n    super();\n    checkSerial(serial);\n    this.serial = serial;\n    this.devices = [];\n    this.portFilter =\n      options.portFilter === undefined\n        ? [{ usbProductId: 37384, usbVendorId: 6991 }]\n        : options.portFilter;\n    this.baudRate = options.baudRate || 115200;\n    this.interCommandDelay =\n      options.interCommandDelay === undefined ? 100 : options.interCommandDelay;\n    this.defaultCommandExpirationDelay =\n      options.defaultCommandExpirationDelay === undefined\n        ? 100\n        : options.defaultCommandExpirationDelay;\n  }\n\n  /**\n   * By calling this method from a click you give users the possibility to allow access to some devices\n   */\n  async requestDevices() {\n    await this.serial.requestPort({\n      filters: this.portFilter,\n    });\n    return this.updateDevices();\n  }\n\n  /**\n   * Update this.devices\n   */\n  async updateDevices() {\n    const serialPorts = await this.serial.getPorts();\n\n    debug('updateDevices');\n\n    const missingDevicesSerialPort = this.devices.filter(\n      (device) => !serialPorts.includes(device.serialPort),\n    );\n    for (let device of missingDevicesSerialPort) {\n      if (device.status !== STATUS_MISSING && device.status !== STATUS_CLOSED) {\n        device.close();\n      }\n      device.status = STATUS_MISSING;\n    }\n\n    for (let serialPort of serialPorts) {\n      let device = this.devices.filter(\n        (device) => device.serialPort === serialPort,\n      )[0];\n      if (device) {\n        await device.ensureOpen();\n      } else {\n        let newDevice = new Device(serialPort, {\n          baudRate: this.baudRate,\n          interCommandDelay: this.interCommandDelay,\n          defaultCommandExpirationDelay: this.defaultCommandExpirationDelay,\n        });\n        this.devices.push(newDevice);\n        await newDevice.open();\n      }\n    }\n    // check if there are any new ports\n  }\n\n  /**\n   * Update this.devices every `scanInterval` [ms].\n   * @param {object} [options={}]\n   * @param {number} [options.scanInterval=1000] Delay between `updateDevices()` calls\n   * @param {number} [options.callback] Callback to execute on each update\n   */\n  async continuousUpdateDevices(options = {}) {\n    const { scanInterval = 1000, callback } = options;\n    while (true) {\n      await this.updateDevices();\n      if (callback) {\n        callback(this.devices);\n      }\n      await delay(scanInterval);\n    }\n  }\n\n  /**\n   * Returns this.devices\n   * @param {object} [options={}]\n   * @param {bool} [options.ready=false] If `true` returns only currently connected device. If `false` returns all devices ever connected.\n   * @returns {Array<object>}\n   */\n  getDevicesList(options = {}) {\n    let { ready = false } = options;\n    return this.devices\n      .filter((device) => !ready || device.isReady())\n      .map((device) => ({\n        status: device.status,\n        id: device.id,\n        queueLength: device.queue.length,\n      }));\n  }\n\n  // private function\n  findDevice(id) {\n    if (id === undefined) return undefined;\n    let devices = this.devices.filter(\n      (device) => device.id === id && device.status === STATUS_OPENED,\n    );\n    if (devices.length === 0) return undefined;\n    if (devices.length > 1) {\n      throw new Error(`Many devices have the same id: ${id}`);\n    }\n    return devices[0];\n  }\n\n  /**\n   * Send a serial command to a device.\n   * @param {number} id ID of the device\n   * @param {string} command Command to send\n   */\n  async sendCommand(id, command) {\n    const device = this.findDevice(id);\n    if (!device) {\n      throw Error(`Device ${id} not found`);\n    }\n    if (device && device.isReady()) return device.get(command);\n    throw Error(`Device ${id} not ready: ${device.port.path}`);\n  }\n}\n","/* eslint-disable no-console */\nexport default function checkSerial(serial) {\n  if (!serial) {\n    console.error(\n      \"Web serial doesn't seem to be enabled in your browser. Try enabling it by visiting:\",\n    );\n    console.error('chrome://flags/#enable-experimental-web-platform-features');\n    console.error('opera://flags/#enable-experimental-web-platform-features');\n    console.error('edge://flags/#enable-experimental-web-platform-features');\n  }\n}\n","export default class EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n\n  on(event, cb) {\n    if (!this.callbacks[event]) this.callbacks[event] = [];\n    this.callbacks[event].push(cb);\n  }\n\n  emit(event, data) {\n    let cbs = this.callbacks[event];\n    if (cbs) {\n      cbs.forEach((cb) => cb(data));\n    }\n  }\n}\n"],"names":["createAbortError","error","Error","name","createDelay","defaultClear","clearTimeout","set","setTimeout","willResolve","ms","timeoutId","settle","rejectFn","value","signal","aborted","Promise","reject","clear","signalListener","delayPromise","resolve","removeEventListener","addEventListener","once","delay","range","minimum","maximum","options","Math","floor","random","randomInteger","createWithTimers","module","exports","STATUS_CREATED","Action","command","this","currentTimeout","undefined","timeout","answer","status","creationTimestamp","Date","now","promise","finishedPromise","finished","startTimestamp","buffer","string","TextDecoder","decode","replace","endsWith","lines","split","length","filter","line","join","STATUS_OPENING","Device","serialPort","id","baudRate","queue","action","interCommandDelay","defaultCommandExpirationDelay","encoder","TextEncoder","decoder","currentProcessQueue","runProcessQueue","shift","start","write","read","open","reader","readable","getReader","writer","writable","getWriter","get","commandExpirationDelay","push","ensureProcessQueue","port","path","emit","event","data","dataArrayBuffer","encode","isFinished","appendAnswer","DevicesManager","serial","console","checkSerial","devices","portFilter","usbProductId","usbVendorId","requestPort","filters","updateDevices","getPorts","serialPorts","missingDevicesSerialPort","device","includes","close","ensureOpen","newDevice","scanInterval","callback","ready","isReady","map","queueLength","findDevice","callbacks","cb","cbs","forEach"],"sourceRoot":""}